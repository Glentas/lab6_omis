#include <algorithm>
#include <cstdlib>
#include <iomanip>
#include <iostream>
#include <string>
#include <vector>

#define CODE_ONE 1.0

template <typename T> void show_mtrx(const std::vector<std::vector<T>> &mtrx);

bool f_eq(float a, float b);

float reverse_norm(float a, float b);

bool check_if_correct(const std::vector<std::vector<float>> &mtrx);

void apply_norm_to_mtrx(std::vector<std::vector<float>> &mtrx,
                        const std::vector<float> concl);

void apply_covering(const std::vector<std::vector<float>> &mtrx,
                    const std::vector<int> &indxs,
                    std::vector<std::vector<std::string>> &results);

std::vector<int> get_covering(const std::vector<std::vector<float>> &mtrx);

void general_inference(const std::vector<std::vector<float>> &mtrx,
                       std::vector<std::vector<std::string>> &results);

std::vector<std::vector<std::string>>
get_results(const std::vector<std::vector<float>> &mtrx);

int main(void) {
  using namespace std;
  vector<vector<float>> mtrx = {
      {0.5, 0.6, 0.1},
      {0.6, 0.7, 0.2},
      {1.0, 1.0, 0.5},
  };
  vector<float> test = {0.6, 0.6, 0.54};

  apply_norm_to_mtrx(mtrx, test);

  cout << "Matrix:";
  show_mtrx<float>(mtrx);

  auto results = get_results(mtrx);

  cout << "\nResults:";
  show_mtrx<string>(results);

  return 0;
}

template <typename T> void show_mtrx(const std::vector<std::vector<T>> &mtrx) {
  using namespace std;
  cout << "\n";
  for (int i = 0; i < mtrx.size(); i++) {
    for (int j = 0; j < mtrx[i].size(); j++) {
      cout << setw(10) << mtrx[i][j];
    }
    cout << "\n";
  }
}

float reverse_norm(float a, float b) {
  if (b == 0) {
    return CODE_ONE;
  }
  if (a / b > 1 || a / b < 0) {
    return CODE_ONE;
  } else {
    return a / b;
  };
}

void apply_norm_to_mtrx(std::vector<std::vector<float>> &mtrx,
                        const std::vector<float> concl) {
  for (int i = 0; i < concl.size(); i++) {
    for (int j = 0; j < mtrx.size(); j++) {
      mtrx[j][i] = reverse_norm(concl[i], mtrx[j][i]);
    }
  }
}

std::vector<std::vector<std::string>>
get_results(const std::vector<std::vector<float>> &mtrx) {
  using namespace std;

  vector<vector<string>> results{};

  if (check_if_correct(mtrx)) {
    auto cover_indxs = get_covering(mtrx);
    if (!cover_indxs.empty()) {
      apply_covering(mtrx, cover_indxs, results);
    } else {
      cout << "\nPrecise solution was not found\n";
      general_inference(mtrx, results);
    }
  }else {
  cout <<"\nImpossible to find solution\n";
  }

  return results;
}

std::vector<int> get_covering(const std::vector<std::vector<float>> &mtrx) {
  using namespace std;

  vector<int> indxs{};
  float prev = -2.0;

  for (int i = 0; i < mtrx.size(); i++) {
    prev = mtrx[i][0];
    for (int j = 0; j < mtrx[i].size(); j++) {
      if (f_eq(mtrx[i][j], prev) && !f_eq(CODE_ONE, mtrx[i][j])) {
        prev = mtrx[i][j];
      } else {
        break;
      }
      if (j == mtrx[i].size() - 1) {
        indxs.push_back(i);
      }
    }
  }

  return indxs;
}

void apply_covering(const std::vector<std::vector<float>> &mtrx,
                    const std::vector<int> &indxs,
                    std::vector<std::vector<std::string>> &results) {
  using namespace std;
  for (auto i : indxs) {
    vector<string> res;
    for (int j = 0; j < mtrx.size(); j++) {
      if (j != i) {
        float min_el = *min_element(mtrx[j].begin(), mtrx[j].end());
        if (f_eq(min_el, CODE_ONE)) {
          min_el = 1.0;
        }
        res.push_back("(0 <= x" + to_string(j) + " <= " + to_string(min_el) +
                      ")");
      } else {
        res.push_back("(x" + to_string(j) + " = " + to_string(mtrx[j][0]) +
                      ")");
      }
    }
    results.push_back(res);
  }
}

void general_inference(const std::vector<std::vector<float>> &mtrx,
                       std::vector<std::vector<std::string>> &results) {
  using namespace std;
  vector<string> res;
  for (int i = 0; i < mtrx.size(); i++) {
    res.push_back("(x" + to_string(i) + " = " +
                  to_string(*min_element(mtrx[i].begin(), mtrx[i].end())) +
                  ")");
  }
  results.push_back(res);
}

bool f_eq(float a, float b) {
  float epsilon = 1e-5;
  return std::abs(a - b) < epsilon;
}

bool check_if_correct(const std::vector<std::vector<float>> &mtrx) {

  for (int i = 0; i < mtrx[0].size(); i++) {
    for (int j = 0; j < mtrx.size(); j++) {
      if (mtrx[i][j] != CODE_ONE) {
        break;
      }
      if (j == mtrx.size() - 1) {
        return false;
      }
    }
  }
  return true;
}
